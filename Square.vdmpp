class Square is subclass of Piece

operations
		public Square: Player ==> Square
		Square(p) == Piece(p);
		
		public checkPiecesMiddle: Tile * Tile ==> bool
		checkPiecesMiddle(ti,tf) == (
				dcl tempX: nat1;
				dcl tempY: nat1;
				dcl max: nat1;
				if(ti.getCoordinates().x = tf.getCoordinates().x)
					then (
								tempX := ti.getCoordinates().x;
								if(ti.getCoordinates().y > tf.getCoordinates().y)
									then (max := ti.getCoordinates().y; tempY := tf.getCoordinates().y)
									else (tempY := ti.getCoordinates().y; max := tf.getCoordinates().y);
								while(tempY < max-1)
									do(
											tempY := tempY + 1;
											if(Board`getInstance().getTile(tempX, tempY).getPiece() <> nil)
												then return false);
								return true
								)
					else(
				 				tempY := ti.getCoordinates().y;
				 				if(ti.getCoordinates().x > tf.getCoordinates().x)
									then (max := ti.getCoordinates().x; tempX := tf.getCoordinates().x)
									else (tempX := ti.getCoordinates().x; max := tf.getCoordinates().x);
								while(tempX < max-1)
									do (tempX := tempX + 1;
											if(Board`getInstance().getTile(tempX, tempY).getPiece() <> nil)
												then return false
											);
								return true
				);
		);
		
		public canMoveTo: Tile * Tile ==> bool
		canMoveTo(ti, tf) == (
			if(ti.isSpecial())
				then (
					return (checkPiecesMiddle(ti, tf) and
									(ti.getCoordinates().x = tf.getCoordinates().x or 
							 		ti.getCoordinates().x = tf.getCoordinates().x))
				)
			else
				return (abs(ti.getCoordinates().x - tf.getCoordinates().x) + abs(ti.getCoordinates().y - tf.getCoordinates().y) = 1)
		)
		pre ti <> tf;
		
		public canMoveTo: Tile * Tile * nat1 ==> bool
		canMoveTo(ti, tf, n) == (
			if(ti.isSpecial())
				then (
					return ((ti.getCoordinates().x = tf.getCoordinates().x or 
							 		ti.getCoordinates().x = tf.getCoordinates().x) and checkPiecesMiddle(ti, tf))
				)
			else
				return ((((abs(ti.getCoordinates().x - tf.getCoordinates().x) <= n) and ti.getCoordinates().x = tf.getCoordinates().x )or 
							 ((abs(ti.getCoordinates().y - tf.getCoordinates().y)) <= n and ti.getCoordinates().x = tf.getCoordinates().x)) and
							 checkPiecesMiddle(ti, tf));
		)
		pre ti <> tf;

		pure public getSize: () ==> nat1
		getSize() == return 1;
		
		pure public getTopPiece: () ==> Piece
		getTopPiece() == return self;

end Square