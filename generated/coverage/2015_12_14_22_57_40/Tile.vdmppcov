class Tile
types
		public Coordinates ::x : nat1
												 y : nat1;
instance variables

		private special: bool;
		private coordinates: Coordinates;
		private piece: [Piece];
		private bigBoard: bool;
		
		inv if bigBoard then coordinates.x in set {1, ..., Board`bigSizeX} and
				coordinates.y in set {1, ..., Board`bigSizeY}
				else coordinates.x in set {1, ..., Board`smallSizeX} and
				coordinates.y in set {1, ..., Board`smallSizeY};
		
operations
		public Tile: nat1 * nat1 * bool ==> Tile
		Tile(xT, yT, boardType) == (
				bigBoard := boardType;
				coordinates := mk_Coordinates(xT, yT);
				piece := nil;
				if(not bigBoard) then
					special:= ((xT = 1 and yT = 1) or (xT = Board`smallSizeX and yT = Board`smallSizeY) or
						(xT = 1 and yT = Board`smallSizeY) or (xT = Board`smallSizeX and yT = 1))
				else special:= ((xT = 1 and yT = 1) or (xT = Board`bigSizeX and yT = Board`bigSizeY) or
						(xT = 1 and yT = Board`bigSizeY) or (xT = Board`bigSizeX and yT = 1));
				return self
		);
		
		public Tile: nat1 * nat1 * Piece * bool ==> Tile
				Tile(xT, yT, p, boardType) == (
				bigBoard := boardType;
				special := false;
				coordinates := mk_Coordinates(xT, yT);
				piece := p;
				return self
		);
		
		pure public getCoordinates: () ==> Coordinates
		getCoordinates() == return coordinates;
		
		pure public getPiece: () ==> [Piece]
		getPiece() == return piece;
		
		pure public isSpecial: () ==> bool
		isSpecial() == return special;
		
		public setPiece: [Piece] ==> ()
		setPiece(p) == piece := p;
		
end Tile