class Piece
types
		public Player = <White> | <Black>; 

instance variables

		protected pieceOfPlayer : Player;
		
operations

		protected Piece: Player ==> Piece
		Piece(p) == pieceOfPlayer := p;
		
		public canMoveTo: Tile * Tile ==> bool
		canMoveTo(ti, tf) == is subclass responsibility
		pre ti.getPiece() <> nil;
		
		public canMoveTo: Tile * Tile * nat1 ==> bool
		canMoveTo(ti, tf, nt) == is subclass responsibility
		pre ti.getPiece() <> nil;
		
		public checkPiecesMiddle: Tile * Tile ==> bool
		checkPiecesMiddle(ti, tf) == is subclass responsibility
		pre ti.getPiece() <> nil;
		
		public moveTo: Tile * Tile ==> bool
		moveTo(ti, tf) == (
				if (canMoveTo(ti, tf) and (tf.getPiece() = nil or ti.getPiece().pieceOfPlayer <> tf.getPiece().pieceOfPlayer))
				then (
					if (tf.getPiece() <> nil and isofclass(Tower, tf.getPiece()) and tf.getPiece().getSize() > 6)
					then return false
					else (
						if tf.getPiece() <> nil and tf.getPiece().getSize() < 6
						then (
							ti.setPiece(nil);
							tf.setPiece(new Tower(pieceOfPlayer, self, tf.getPiece()));
							capturePiece(tf.getPiece());
							return true;
						)
						else (
							ti.setPiece(nil);
							tf.setPiece(self);
							return true;
						)
					);
				)
				else return false;
		)
		pre ti.getPiece() <> nil;
		--post tf.getPiece() = ti~.getPiece(); not supported 
		
		public moveTo: Tile * Tile * nat1 ==> bool
		moveTo(ti, tf, nt) == is subclass responsibility
		pre ti.getPiece() <> nil;
		
		public capturePiece: Piece ==> ()
		capturePiece(p) == (
				if pieceOfPlayer = <White> then pieceOfPlayer := <Black>
					else pieceOfPlayer := <White>;
		)
		pre p <> self;
		
		pure public getSize: () ==> nat1
		getSize() == return 1;
	
end Piece