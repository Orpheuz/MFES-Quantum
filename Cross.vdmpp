class Cross is subclass of Piece

operations

		public Cross: Player ==> Cross
		Cross(p) == Piece(p);

		public checkPiecesMiddle: Tile * Tile ==> bool
		checkPiecesMiddle(ti,tf) == (
				dcl tempX: nat1;
				dcl tempY: nat1;
				dcl maxX: nat1;
				--dcl maxY: nat1;
				dcl tempXc: nat1 := ti.getCoordinates().x;
				dcl tempYc: nat1 := ti.getCoordinates().y;
				dcl signalX: bool := false;
				dcl signalY: bool := false;
				if(ti.getCoordinates().x = tf.getCoordinates().x and ti.getCoordinates().y <> tf.getCoordinates().y)
					then (
								tempX := ti.getCoordinates().x;
								if(ti.getCoordinates().y > tf.getCoordinates().y)
									then (maxX := ti.getCoordinates().y; tempY := tf.getCoordinates().y)
									else (tempY := ti.getCoordinates().y; maxX := tf.getCoordinates().y);
								while(tempY < maxX-1)
									do(tempY := tempY + 1;
											if(Board`getInstance().getTile(tempX, tempY).getPiece() <> nil)
													then return false);
									return true
								);
				if(ti.getCoordinates().x <> tf.getCoordinates().x and ti.getCoordinates().y = tf.getCoordinates().y)
					then(
				 		tempY := ti.getCoordinates().y;
				 		if(ti.getCoordinates().x > tf.getCoordinates().x)
							then (maxX := ti.getCoordinates().x; tempX := tf.getCoordinates().x)
							else (tempX := ti.getCoordinates().x; maxX := tf.getCoordinates().x);
							while(tempX < maxX-1)
								do (tempX := tempX + 1;
										if(Board`getInstance().getTile(tempX, tempY).getPiece() <> nil)
												then return false
										);
								return true
						)
				else (
					if(tf.getCoordinates().x > ti.getCoordinates().x)
					then signalX := true;
				if(tf.getCoordinates().y > ti.getCoordinates().y)
					then signalY := true;
				while(tempXc <> tf.getCoordinates().x and tempYc <> tf.getCoordinates().y)
						do (
								if(signalX)
									then tempXc := tempXc + 1
								else	tempXc := tempXc - 1;
								if(signalY)
									then tempYc := tempYc + 1
								else
									tempYc := tempYc-1;
								if(Board`getInstance().getTile(tempXc, tempYc).getPiece() <> nil)
									then return false;
								);
				return true;
				);
		);

    -- checks if can move between two different tiles
		public canMoveTo: Tile * Tile ==> bool
		canMoveTo(ti, tf) == (
			if(ti.isSpecial())
				then (
					return (checkPiecesMiddle(ti, tf) and
									(ti.getCoordinates().x = tf.getCoordinates().x or
					 				ti.getCoordinates().y = tf.getCoordinates().y or
					 				(abs(ti.getCoordinates().x - tf.getCoordinates().x) = abs(ti.getCoordinates().y - tf.getCoordinates().y))));
				)
			else
				return abs(ti.getCoordinates().x - tf.getCoordinates().x) <= 1 and
							 abs(ti.getCoordinates().y - tf.getCoordinates().y) <= 1
				-- and
					--			abs(ti.getCoordinates().x - tf.getCoordinates().x) = 1 and
						--		abs(ti.getCoordinates().y - tf.getCoordinates().y) = 1) 
							--	or (abs(ti.getCoordinates().x - tf.getCoordinates().x) = 1 or 
							 	--abs(ti.getCoordinates().y - tf.getCoordinates().y) = 1);
		) pre ti <> tf;
		
		public canMoveTo: Tile * Tile * nat1 ==> bool
		canMoveTo(ti, tf, n) == (
			if(ti.isSpecial())
				then (
					return ((ti.getCoordinates().x = tf.getCoordinates().x or
					 				ti.getCoordinates().y = tf.getCoordinates().y or
					 				(abs(ti.getCoordinates().x - tf.getCoordinates().x) = abs(ti.getCoordinates().y - tf.getCoordinates().y))) and
					 				checkPiecesMiddle(ti, tf));
				)
			else
				return abs(ti.getCoordinates().x - tf.getCoordinates().x) <= n and abs(ti.getCoordinates().y - tf.getCoordinates().y) <= n
		)
		pre ti <> tf;
		
		pure public getSize: () ==> nat1
		getSize() == return 1;
		
		pure public getTopPiece: () ==> Piece
		getTopPiece() == return self;
		
end Cross