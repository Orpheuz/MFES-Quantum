class MovementTest is subclass of QuantumTest

operations  

  public testCanMoveto_Circle: () ==> ()
  testCanMoveto_Circle() == (
  	dcl p: Piece := new Circle();
  	dcl t:Tile := new Tile(3,3,p,false);
  	dcl t2:Tile := new Tile(2,2,false);
  	dcl t3:Tile := new Tile(4,2,false);
  	dcl t4:Tile := new Tile(5,5,false);
  	dcl t5:Tile := new Tile(3,4,false);
  	dcl t6:Tile := new Tile(2,3,false);
  	assertEqual(true, p.canMoveTo(t, t2));
  	assertEqual(true, p.canMoveTo(t, t3));
  	assertEqual(false, p.canMoveTo(t, t6)); -- movimento na vertical
  	assertEqual(false, p.canMoveTo(t, t5)); -- movimento horizontal
  	assertEqual(false, p.canMoveTo(t, t4)); -- mais casas do que o permitido
  );
  
  public testCanMoveto_Square: () ==> ()
  testCanMoveto_Square() == (
  	dcl p: Piece := new Square();
  	dcl t:Tile := new Tile(2,2,p,false);
  	dcl t2:Tile := new Tile(1,2,false);
  	dcl t3:Tile := new Tile(2,3,false);
  	dcl t4:Tile := new Tile(2,6,false);
  	dcl t5:Tile := new Tile(3,3,false);
  	assertEqual(true, p.canMoveTo(t, t2));
  	assertEqual(true, p.canMoveTo(t, t3));
  	assertEqual(false, p.canMoveTo(t, t5)); -- movimento na diagonal
  	assertEqual(false, p.canMoveTo(t, t4)); -- mais casas do que o permitido
  );
  
  public testCanMoveto_Cross: () ==> ()
  testCanMoveto_Cross() == (
  	dcl p: Piece := new Cross();
  	dcl t:Tile := new Tile(2,2,p,false);
  	dcl t2:Tile := new Tile(1,2,false);
  	dcl t3:Tile := new Tile(2,3,false);
  	dcl t4:Tile := new Tile(3,1,false);
  	dcl t5:Tile := new Tile(1,1,false);
  	assertEqual(true, p.canMoveTo(t, t2));
  	assertEqual(true, p.canMoveTo(t, t3));
  	assertEqual(true, p.canMoveTo(t, t4));
  	assertEqual(true, p.canMoveTo(t, t5));
  );
  
  public testCanMoveto_TowerSquare: () ==> ()
  testCanMoveto_TowerSquare() == (
  	dcl p: Piece := new Circle(<Black>);
  	dcl p2: Piece := new Circle(<White>);
  	dcl t: Piece := new Tower(<Black>, p, [p2]);
  	dcl p3: Piece := new Square(<White>);
  	  	
  	dcl tl1: Tile := new Tile(4,4,t,false);
  	dcl tl2: Tile := new Tile(4,3,false);
  	dcl tl3: Tile := new Tile(4,2,false);
  	dcl tl4: Tile := new Tile(3,3, p3,false);

  	t.capturePiece(p3);
  	-- check if after capture tower leaves previous position
  	-- assertEqual(tl1.getPiece() = nil, true);
  	assertEqual(3, t.getSize());
  	assertEqual(true, t.canMoveTo(tl1, tl2));
		assertEqual(true, t.canMoveTo(tl1, tl3));
  	assertEqual(false, t.canMoveTo(tl1, tl4));
  );
  
  public testCanMoveto_TowerCircle: () ==> ()
  testCanMoveto_TowerCircle() == (
 		dcl board: Board := Board`getInstance();
  	dcl p: Piece := new Circle(<Black>);
  	dcl p2: Piece := new Circle(<Black>);
  	dcl p3: Piece := new Square(<White>);
  	dcl t: Piece := new Tower(<White>, p3, [p]);
  	
  	dcl tl1: Tile := new Tile(4,4,false);
  	dcl tl2: Tile := new Tile(4,3,false);
  	dcl tl3: Tile := new Tile(4,2,false);
  	dcl tl4: Tile := new Tile(3,3,false);
  	dcl tl5: Tile := new Tile(2,2,false);
  	board.setBoardType(false);
  	
  	assertEqual(false, t.canMoveTo(tl1, tl4));
		assertEqual(false, t.canMoveTo(tl1, tl5));
  	assertEqual(true, t.canMoveTo(tl1, tl2));
  	t.capturePiece(p2);
  	assertEqual(false, t.canMoveTo(tl1, tl2));
  --	assertEqual(false, t.canMoveTo(tl1, tl3));
  --	assertEqual(true, isofclass(Circle, t.getTopPiece()));
  --	board.getTile(3,3).setPiece(nil);
  --	assertEqual(3, t.getSize());
  --	assertEqual(true, t.canMoveTo(tl1, tl4));
  --	assertEqual(true, t.canMoveTo(tl1, tl5));
  --	assertEqual(true, t.canMoveTo(tl4, tl1));
  --	assertEqual(true, t.canMoveTo(tl5, tl1));
  );
  
  public testCanMoveto_TowerCross: () ==> ()
  testCanMoveto_TowerCross() == (
  	dcl board: Board := Board`getInstance();
  	dcl p: Piece := new Circle(<Black>);
  	dcl p3: Piece := new Cross(<Black>);
  	dcl p2: Piece := new Square(<White>);
  	dcl t: Piece := new Tower(<White>, p2, [p]);
  	
  	dcl tl1: Tile := new Tile(4,4,false);
  	dcl tl2: Tile := new Tile(4,3,false);
  	dcl tl3: Tile := new Tile(4,2,false);
  	dcl tl4: Tile := new Tile(3,3,false);
  	dcl tl5: Tile := new Tile(2,2,false);
  	dcl tl6: Tile := new Tile(3,2,false);
  	dcl tl7: Tile := new Tile(1,1,false);
  	dcl tl8: Tile := new Tile(5,5,false);
  	board.setBoardType(false);

  	assertEqual(false, t.canMoveTo(tl1, tl4));
		assertEqual(false, t.canMoveTo(tl1, tl5));
  	assertEqual(true, t.canMoveTo(tl1, tl2));
  	t.capturePiece(p3);
  	assertEqual(true, t.canMoveTo(tl1, tl2));
  	assertEqual(true, t.canMoveTo(tl1, tl3));
  	assertEqual(true, t.canMoveTo(tl1, tl5));
  	assertEqual(true, t.canMoveTo(tl1, tl4));
  	assertEqual(true, t.canMoveTo(tl1, tl6));
  	assertEqual(false, t.canMoveTo(tl8, tl7));
  );
  
  public testPowerTile: () ==> ()
  testPowerTile() == (
  	dcl board: Board := Board`getInstance();
  	dcl ps: Piece := new Square();
  	dcl pc: Piece := new Circle();
  	dcl pcr: Piece := new Cross();
  	board.setBoardType(false);
  	
  	assertEqual(true, board.getInstance().getTile(1,1).isSpecial());
  	board.getInstance().getTile(1,1).setPiece(ps);
  	board.getInstance().getTile(4,1).setPiece(nil);
  	assertEqual(false, board.getInstance().getTile(1,1).getPiece().canMoveTo(board.getInstance().getTile(1,1), board.getInstance().getTile(2,2)));
  	board.getInstance().getTile(2,1).setPiece(nil);
  	board.getInstance().getTile(3,1).setPiece(nil);
  	assertEqual(true, board.getInstance().getTile(1,1).getPiece().canMoveTo(board.getInstance().getTile(1,1), board.getInstance().getTile(4,1)));
  	board.getInstance().getTile(1,1).setPiece(pc);
  	board.getInstance().getTile(2,2).setPiece(nil);
  	board.getInstance().getTile(3,3).setPiece(nil);
  	assertEqual(true, board.getInstance().getTile(1,1).getPiece().canMoveTo(board.getInstance().getTile(1,1), board.getInstance().getTile(3,3)));
  	
  	board.getInstance().getTile(4,4).setPiece(pc);
  	board.getInstance().getTile(3,3).setPiece(nil);
  	board.getInstance().getTile(2,2).setPiece(nil);
  	--assertEqual(true, board.getInstance().getTile(4,4).getPiece().canMoveTo(board.getInstance().getTile(4,4), board.getInstance().getTile(2,2)));
  	-- testing cross piece in special tile
  	board.getInstance().getTile(1,1).setPiece(pcr);
  	board.getInstance().getTile(1,2).setPiece(nil);
  	board.getInstance().getTile(1,3).setPiece(nil);
  	assertEqual(true, board.getInstance().getTile(1,1).getPiece().canMoveTo(board.getInstance().getTile(1,1), board.getInstance().getTile(1,3)));
  	board.getInstance().getTile(2,1).setPiece(nil);
  	board.getInstance().getTile(3,1).setPiece(nil);
  	assertEqual(true, board.getInstance().getTile(1,1).getPiece().canMoveTo(board.getInstance().getTile(1,1), board.getInstance().getTile(3,1)));
  	board.getInstance().getTile(1,3).setPiece(pcr);
  	board.getInstance().getTile(1,2).setPiece(new Circle());
  	board.getInstance().getTile(1,1).setPiece(nil);
  	assertEqual(false, board.getInstance().getTile(1,3).getPiece().canMoveTo(board.getInstance().getTile(1,3), board.getInstance().getTile(1,1)));
  	board.getInstance().getTile(3,1).setPiece(pcr);
  	board.getInstance().getTile(2,1).setPiece(new Square());
  	board.getInstance().getTile(1,1).setPiece(nil);
  	assertEqual(false, board.getInstance().getTile(3,1).getPiece().canMoveTo(board.getInstance().getTile(3,1), board.getInstance().getTile(1,1)));
  	
  	
  );
  
  public testMove: () ==> ()
  testMove() == (
  	dcl p: Piece := new Circle(<Black>);
  	dcl tl1: Tile := new Tile(1,1, p,false);
  	dcl tl2: Tile := new Tile(2,2,false);
  	dcl p2: Piece := new Square(<White>);
  	dcl tl3: Tile := new Tile(1,1, p2,false);
  	dcl tl4: Tile := new Tile(2,1,false);
  	dcl p3: Piece := new Cross();
  	dcl tl5: Tile := new Tile(1,1, p3,false);
  	dcl tl6: Tile := new Tile(2,3,false);
  	dcl tl7: Tile := new Tile(1,2,false);
  	
  	assertEqual(true, p.moveTo(tl1, tl2));
  	assertEqual(false, tl2.getPiece() = nil);
  	assertEqual(nil, tl1.getPiece());
  	
  	assertEqual(true, p2.moveTo(tl3, tl4));
  	assertEqual(false, (tl4.getPiece() = nil));
  	assertEqual(nil, tl3.getPiece());
  	
  	assertEqual(true, p3.moveTo(tl5, tl7));
  	assertEqual(false, tl7.getPiece() = nil);
  	assertEqual(nil, tl5.getPiece());
  	assertEqual(true, p3.moveTo(tl7, tl6));
  	assertEqual(false, tl6.getPiece() = nil);
  	assertEqual(nil, tl7.getPiece());
  
  );
  
  public testTowerCapture: () ==> ()
  testTowerCapture() == (
  	dcl p: Piece := new Circle(<Black>);
  	dcl p3: Piece := new Cross(<White>);
  	dcl p4: Piece := new Cross(<Black>);
  	dcl p2: Piece := new Square(<White>);
  	dcl t: Piece := new Tower(<White>, p2, [p]);
  	
  	assertEqual(t.getSize(), 2);
  	t.capturePiece(p4);
  	assertEqual(3, t.getSize());
  	t.capturePiece(p3);
  	assertEqual(4, t.getSize());
  );
  
  public testCanMoveto_Tower_AfterCapture: () ==> ()
  testCanMoveto_Tower_AfterCapture() == (
  	dcl p: Piece := new Square(<Black>);
  	dcl p2: Piece := new Cross(<White>);
  	dcl t: Tower := new Tower(<White>, p2, [p]);
  	dcl p3: Piece := new Circle(<Black>);
  	dcl p4: Piece := new Square(<White>);
  	dcl p5: Piece := new Circle(<Black>);
  	dcl p6: Piece := new Square(<White>);
  	dcl tl1: Tile := new Tile(1,2,false);
  	dcl tl2: Tile:= new Tile(1,1,false);
  	
  	t.capturePiece(p3);
  	t.capturePiece(p4);
  	assertEqual(true, t.canMoveTo(tl2, tl1));
  	t.capturePiece(p5);
  	t.capturePiece(p6);
  	assertEqual(6, t.getSize());
  );  
  
  
  -- ver captura de torres completas
  public testTowerCaptureTower: () ==> ()
  testTowerCaptureTower() == (
  	dcl p: Piece := new Square(<White>);		
  	dcl p2: Piece := new Cross(<Black>);
  	dcl p3: Piece := new Square(<Black>);
  	dcl p4: Piece := new Cross(<White>);
  	dcl p5: Piece := new Cross(<White>);
  	dcl p6: Piece := new Cross(<Black>);
  	dcl p7: Piece := new Cross(<Black>);
  	dcl t: Piece := new Tower(<White>,p,[p2]);
  	dcl t2: Piece := new Tower(<Black>,p3,[p4]);
  	
  	t2.capturePiece(p5);
  	t2.capturePiece(p7);
  	t.capturePiece(p6);
  	assertEqual(3, t.getSize());
  	assertEqual(4, t2.getSize());
  	t.capturePiece(t2);
  	assertEqual(7, t.getSize())
  );  
  
  public testPieceMoveandCapture: () ==> ()
  testPieceMoveandCapture() == (
  	dcl p2: Piece := new Square(<Black>);
  	dcl p3: Piece := new Circle(<White>);
  	
  	dcl tl11: Tile := new Tile(1,1,p2,false);
  	dcl tl21: Tile := new Tile(2,1,false);
  	dcl tl31: Tile := new Tile(3,1,p3,false);
  	
  	--simple movement with capture
  	assertEqual(tl11.getPiece() = nil, false);
  	assertEqual(tl21.getPiece() = nil, true);
  	assertEqual(true, p2.moveTo(tl11, tl21));
  	assertEqual(tl11.getPiece() = nil, true);
  	assertEqual(tl21.getPiece() = nil, false);
  	assertEqual(true, p2.moveTo(tl21, tl31));
  	assertEqual(tl21.getPiece() = nil, true);
  	assertEqual(tl31.getPiece() = nil, false);
  	assertEqual(tl31.getPiece().getSize(), 2);
  );
   
  public testTowerMoveandCapture: () ==> ()
  testTowerMoveandCapture() == (
  	dcl p: Piece := new Circle(<White>);
  	dcl p2: Piece := new Circle(<Black>);
  	dcl t: Piece := new Tower(<Black>, p2, [p]);
  	dcl p3: Piece := new Square(<White>);
  	dcl p4: Piece := new Cross(<Black>);
  	
  	dcl tl11: Tile := new Tile(1,1,t,false);
  	dcl tl22: Tile := new Tile(2,2,false);
  	dcl tl33: Tile := new Tile(3,3,p3,false);
  	dcl tl31: Tile := new Tile(3,1,false);
  	dcl tl32: Tile := new Tile(3,2,p4,false);
  	
  	--simple movement with capture
  	assertEqual(tl11.getPiece() = nil, false);
  	assertEqual(tl22.getPiece() = nil, true);
  	assertEqual(true, t.canMoveTo(tl11, tl22));
  	assertEqual(true, t.moveTo(tl11, tl22));
  	assertEqual(true, t.canMoveTo(tl22, tl33));
  	assertEqual(true, t.moveTo(tl22, tl33));
  	assertEqual(tl22.getPiece() = nil, true);
  	assertEqual(tl33.getPiece() = nil, false);
  	assertEqual(3, tl33.getPiece().getSize());
  	assertEqual(tl32.getPiece() <> nil, true);
  	assertEqual(true, t.canMoveTo(tl33, tl31));
  	assertEqual(true, t.moveTo(tl33, tl31));
  	assertEqual(true, t.canMoveTo(tl31, tl32));
  --	assertEqual(true, t.moveTo(tl31, tl32));
  	
  );
  
  public GameCicleTest: () ==> ()
	GameCicleTest() == (
		dcl n: bool := false;
		dcl q: Quantum := new Quantum(n);
		assertEqual(q.getGameState() = <NotStarted>, true);
		q.startGame();
		assertEqual(q.getGameState() = <Playing>, true);
		assertEqual(q.getActualPlayer(), <Player1>);
		q.endTurn();
		assertEqual(q.getActualPlayer(), <Player2>);
		q.endTurn();
		assertEqual(q.getActualPlayer(), <Player1>);
	);
	
	public GameOverTest: () ==> ()
	GameOverTest() == (
		dcl q: Quantum := new Quantum(false);
		dcl p: Piece := new Circle();
		q.startGame();
		assertEqual(isofclass(Square, q.board.getTile(5,5).getPiece()), true);
		assertEqual(q.movePieceTo(5, 5, 4, 5), true);
		q.endTurn(); q.endTurn();
		assertEqual(q.movePieceTo(4, 5, 3, 5), true);
		q.endTurn(); q.endTurn();
		assertEqual(1, q.board.getTile(3,5).getPiece().getSize());
		assertEqual(<Black>, q.board.getTile(2,5).getPiece().getPlayer());
		assertEqual(q.movePieceTo(3, 5, 2, 5), true);
		assertEqual(2, q.board.getTile(2,5).getPiece().getSize());
		q.endTurn(); q.endTurn();
		assertEqual(true, q.board.getTile(1,5).getPiece() <> nil);
		--assertEqual(q.board.getTile(1,5).getPiece().getSize(), 3);
		--q.isGameOver();
		--assertEqual(q.getGameState() = <Player2Won>, true);
	);
   
  public testAll: () ==> ()
  testAll() == (
    testCanMoveto_Circle();
    testCanMoveto_Square();
  	testCanMoveto_Cross();
    testCanMoveto_TowerCircle();
  --  testCanMoveto_TowerSquare();
  --	testCanMoveto_TowerCross();
  	testTowerCapture();
  	testCanMoveto_Tower_AfterCapture();
  	testTowerCaptureTower();
  	testMove();
  	testPowerTile();  
  --	testPieceMoveandCapture();	
  --	testTowerMoveandCapture();
  	GameCicleTest();
  	GameOverTest();
  );
  
end MovementTest