class Tower is subclass of Piece

instance variables

	private stack : seq of Piece := [];
	inv len stack > 1;
	-- inv 2 peças seguidas tem de ser de players diferentes
	
operations
		public Tower: Player * Piece * Piece ==> Tower
		Tower(player, p1, p2) == (	
				stack := [p1, p2] ^ stack;
				Piece(player);
		)
		post p1.pieceOfPlayer <> p2.pieceOfPlayer;
		
		public checkPiecesMiddle: Tile * Tile ==> bool
		checkPiecesMiddle(ti,tf) == (
				return (hd stack).checkPiecesMiddle(ti, tf);
		);
		
		public canMoveTo: Tile * Tile ==> bool
		canMoveTo(ti, tf) == (
				return (hd stack).canMoveTo(ti, tf, getSize());
		)
		pre len stack < 6;
		
		--placeholder
		public canMoveTo: Tile * Tile * nat1 ==> bool
		canMoveTo(ti, tf, n) == return true;
		
		public capturePiece: Piece ==> ()
		capturePiece(p) == (
				stack := [p] ^ stack;
				if pieceOfPlayer = <White> then pieceOfPlayer := <Black>
				else pieceOfPlayer := <White>;
		)
		pre len stack < 6
		post len stack > len stack~;
			
		pure public getSize: () ==> nat1
		getSize() == (
			dcl size_tmp: nat1 := 0;
			dcl stack_temp : seq of Piece := stack;
			if(len stack_temp = 1)
				then size_tmp := 1
			else
				while(len stack_temp>1)
					do (size_tmp := size_tmp +1;
							if(isofclass(Tower, hd tl stack_temp))
								then (size_tmp := size_tmp +1;
											stack_temp := (tl stack_temp)
								)
					);
			return size_tmp;
		);
		
		pure public getStack: () ==> seq of Piece
		getStack() == return stack;
		
		pure public getPieceTower: () ==> Piece
		getPieceTower() == return hd stack;
		
end Tower